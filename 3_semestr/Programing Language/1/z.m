%define SYS_EXIT        60
%define SYS_WRITE       1
%define SPACE     0x20
%define TAB       0x9
%define NEW_LINE  0xA

section .text

; Принимает код возврата и завершает текущий процесс
exit:
    mov rax, SYS_EXIT   ; Устанавливаем номер системного вызова для выхода в rax
    syscall             ; Вызываем системный вызов для завершения процесса

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax         ; Обнуляем rax, который будет хранить длину строки
.loop:
    cmp byte [rdi + rax], 0   ; Сравниваем байт по адресу rdi + rax с нулем
    je .end                    ; Если это нулевой символ, значит, строка закончилась, и мы завершаем цикл
    inc rax                    ; Увеличиваем счетчик символов
    jmp .loop                  ; Переходим на следующую итерацию цикла
.end:
    ret                        ; Возвращаем длину строки в rax


; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_string:
    push rdi                  ; Сохраняем значение регистра rdi на стеке
    call string_length        ; Вызываем функцию string_length для определения длины строки
    pop rsi                   ; Восстанавливаем значение регистра rdi из стека в rsi
    mov rdx, rax              ; Помещаем длину строки в rdx (для системного вызова SYS_WRITE)
    mov rax, SYS_WRITE        ; Устанавливаем номер системного вызова для записи в rax
    mov rdi, SYS_WRITE        ; Устанавливаем файловый дескриптор stdout в rdi
    syscall                   ; Вызываем системный вызов для вывода строки в stdout
    ret                       ; Возвращаемся из функции


; Принимает код символа и выводит его в stdout
print_char:
    xor rax, rax           ; Обнуляем rax
    push rdi               ; Сохраняем значение rdi на стеке
    mov rsi, rsp           ; Устанавливаем rsi равным адресу в стеке
    mov rdi, SYS_WRITE     ; Устанавливаем файловый дескриптор stdout в rdi
    mov rax, SYS_WRITE     ; Устанавливаем номер системного вызова для записи в rax
    mov rdx, SYS_WRITE     ; Устанавливаем количество байт для записи (1)
    syscall                ; Вызываем системный вызов для вывода символа в stdout
    pop rdi                ; Восстанавливаем значение rdi из стека
    ret                    ; Возвращаемся из функции


; Переводит строку (выводит символ с кодом 0xA)
print_newline:
    xor rax, rax       ; Обнуляем rax
    mov rdi, 0xA       ; Устанавливаем значение для символа новой строки
    call print_char    ; Вызываем функцию print_char для вывода символа
    ret                ; Возвращаемся из функции



; Выводит беззнаковое 8-байтовое число в десятичном формате
print_uint:
    mov rax, rdi       ; Копируем беззнаковое число в rax
    mov rdi, rsp       ; Устанавливаем rdi равным вершине стека
    dec rdi            ; Сдвигаем rdi на один байт, чтобы освободить место для нуль-терминатора
    mov rcx, 10        ; Устанавливаем rcx равным 10 (основание системы счисления)
    sub rsp, 32         ; Распределяем место на стеке для временных данных
    mov byte [rdi], 0   ; Устанавливаем нуль-терминатор в конец строки
.loop:
    xor rdx, rdx       ; Обнуляем rdx
    div rcx            ; Делим rax на 10, результат в rax, остаток в rdx
    add dl, '0'        ; Преобразуем остаток в ASCII-символ
    dec rdi            ; Сдвигаемся влево по строке
    mov [rdi], dl      ; Записываем ASCII-символ в строку
    test rax, rax      ; Проверяем, равен ли rax нулю (завершение цикла)
    jz .end             ; Если rax равен нулю, завершаем цикл
    jmp .loop           ; Переходим к следующей итерации цикла
.end:
    call print_string   ; Выводим строку
    add rsp, 32         ; Освобождаем выделенное место на стеке
    ret                ; Возвращаемся из функции



; Выводит знаковое 8-байтовое число в десятичном формате
print_int:
    xor rax, rax         ; Обнуляем rax
    test rdi, rdi        ; Проверяем, положительное или отрицательное число
    jge .print           ; Если положительное, переходим к выводу
    push rdi             ; Сохраняем значение rdi на стеке
    mov rdi, '-'         ; Устанавливаем значение для символа минуса
    call print_char      ; Вызываем функцию print_char для вывода минуса
    pop rdi              ; Восстанавливаем значение rdi из стека
    neg rdi              ; Инвертируем число (делаем его положительным)
.print:
    jmp print_uint       ; Переходим к выводу беззнакового числа



; Принимает два указателя на нуль-терминированны
; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    xor rax, rax         ; Обнуляем rax (будет хранить результат сравнения)
    xor rcx, rcx         ; Обнуляем rcx (будет использоваться в цикле)
    mov rax, 1           ; Устанавливаем rax в 1 (предполагаем, что строки равны)
    push r8              ; Сохраняем значение р8 на стеке
    push r9              ; Сохраняем значение r9 на стеке
.loop:
    mov r8b, byte [rdi + rcx]  ; Загружаем байт из первой строки
    mov r9b, byte [rsi + rcx]  ; Загружаем байт из второй строки
    cmp r8b, r9b               ; Сравниваем байты
    jne .exit2                 ; Если они не равны, переходим к .exit2
    cmp r8b, 0                 ; Проверяем, достигли ли конца строки
    test r8b, r8b
    jz .exit1                  ; Если да, переходим к .exit1
    inc rcx                    ; Увеличиваем счетчик символов и переходим к следующей итерации цикла
    jmp .loop                  ; Повторяем цикл
.exit1:
    pop r9                     ; Восстанавливаем значение r9 из стека
    pop r8                     ; Восстанавливаем значение r8 из стека
    ret                        ; Возвращаем 1, так как строки равны
.exit2:
    xor rax, rax               ; Обнуляем rax (устанавливаем в 0, так как строки не равны)
    pop r9                     ; Восстанавливаем значение r9 из стека
    pop r8                     ; Восстанавливаем значение r8 из стека
    ret                        ; Возвращаем 0, так как строки не равны



; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
   read_char:
    xor rax, rax      ; Обнуляем rax
	push 0             ; Резервируем место на стеке для временного значения
   	xor rax, rax      ; Обнуляем rax
	xor rdi, rdi      ; Обнуляем rdi
	mov rsi, rsp      ; Устанавливаем rsi равным адресу в стеке
	mov rdx, 1        ; Устанавливаем количество байт для чтения (1)
	syscall            ; Вызываем системный вызов для чтения символа
    cmp rax, 0          ; Сравниваем результат с 0
    test rax, rax
    js .end             ; Если rax меньше 0, переходим к .end
    pop rax             ; Восстанавливаем значение rax из стека
 .end:
    ret                  ; Возвращаем считанный символ (или 0 при достижении конца потока)
; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале.
; Пробельные символы - это пробел (0x20), табуляция (0x9) и символ перевода строки (0xA).
; Останавливается и возвращает 0, если слово слишком большое для буфера.
; При успехе возвращает адрес буфера в rax, длину слова в rdx.
read_word:
    push r12               ; Сохраняем значение р12 на стеке
    push r13               ; Сохраняем значение r13 на стеке
    push r14               ; Сохраняем значение r14 на стеке
    xor rcx, rcx           ; Обнуляем rcx (счетчик символов)
.loop:
    mov r12, rcx           ; Сохраняем значение счетчика символов в r12
    mov r13, rdi           ; Сохраняем значение указателя на буфер в r13
    mov r14, rsi           ; Сохраняем значение указателя на временный буфер в r14
    call read_char         ; Вызываем функцию read_char для чтения символа
    mov rcx, r12           ; Восстанавливаем значение счетчика символов из r12
    mov rdi, r13           ; Восстанавливаем указатель на буфер из r13
    mov rsi, r14           ; Восстанавливаем указатель на временный буфер из r14
    cmp rax, SPACE         ; Сравниваем считанный символ с пробелом (0x20)
    je .search_space       ; Если символ - пробел, переходим к .search_space
    cmp rax, TAB           ; Сравниваем считанный символ с табуляцией (0x9)
    je .search_space       ; Если символ - табуляция, переходим к .search_space
    cmp rax, NEW_LINE      ; Сравниваем считанный символ с символом перевода строки (0xA)
    je .search_space       ; Если символ - символ перевода строки, переходим к .search_space
    test rax, rax          ; Проверяем, равен ли считанный символ нулю (конец потока)
    jz .end                 ; Если да, завершаем цикл
    cmp rsi, rcx           ; Сравниваем счетчик символов с размером буфера
    je .exit                ; Если счетчик равен размеру буфера, завершаем парсинг
    mov byte [rdi + rcx], al ; Копируем считанный символ в буфер
    inc rcx                ; Увеличиваем счетчик символов
    jmp .loop              ; Повторяем цикл
.search_space:
    test rcx, rcx          ; Проверяем, равен ли счетчик символов нулю
    je .loop               ; Если да, переходим к следующей итерации цикла
.end:
    mov byte [rdi + rcx], 0  ; Устанавливаем нуль-терминатор в конец буфера
    mov rdx, rcx             ; Передаем длину слова в rdx
    mov rax, rdi             ; Передаем адрес буфера в rax
    pop r14                  ; Восстанавливаем значение r14 из стека
    pop r13                  ; Восстанавливаем значение r13 из стека
    pop r12                  ; Восстанавливаем значение r12 из стека
    ret                      ; Возвращаем адрес буфера и длину слова
.exit:
    pop r14                  ; Восстанавливаем значение r14 из стека
    pop r13                  ; Восстанавливаем значение r13 из стека
    pop r12                  ; Восстанавливаем значение r12 из стека
    xor rax, rax             ; Обнуляем rax (устанавливаем в 0, так как слово слишком большое для буфера)
    ret                      ; Возвращаем 0



parse_uint:
    xor rax, rax         ; Обнуляем rax (будет хранить число)
    xor rcx, rcx         ; Обнуляем rcx (будет использоваться в цикле)
    xor r8, r8           ; Обнуляем r8 (будет хранить текущую цифру)
    mov r9, 10           ; Устанавливаем r9 в 10 (основание системы счисления)
.loop:
    mov r8b, byte [rdi + rcx]  ; Загружаем байт из строки
    cmp r8b, '0'               ; Сравниваем с символом '0'
    jb .exit                   ; Если меньше '0', завершаем парсинг
    cmp r8b, '9'               ; Сравниваем с символом '9'
    ja .exit                   ; Если больше '9', завершаем парсинг
    sub r8b, '0'               ; Преобразуем ASCII-символ в число
    inc rcx                    ; Увеличиваем счетчик символов
    mul r9                     ; Умножаем текущее число на 10
    add rax, r8                ; Добавляем новую цифру к числу
    jmp .loop                  ; Повторяем цикл
.exit:
    mov rdx, rcx                ; Сохраняем длину числа в rdx
    ret                         ; Возвращаем число в rax и длину в rdx

; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    xor rax, rax                 ; Обнуляем rax (будет хранить число)
    cmp byte [rdi], '-'          ; Проверяем, есть ли минус в начале строки
    jne parse_uint               ; Если нет, переходим к парсингу беззнакового числа
    inc rdi                      ; Пропускаем минус
    call parse_uint              ; Вызываем парсинг беззнакового числа
    inc rdx                      ; Увеличиваем длину на 1
; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    xor rax, rax                ; Обнуляем rax (будет хранить результат)
    xor rcx, rcx                ; Обнуляем rcx (счетчик символов)
.loop:
    cmp rdx, rcx                ; Сравниваем счетчик символов с длиной буфера
    je .error                   ; Если счетчик равен длине буфера, завершаем
    cmp byte [rdi + rcx], 0    ; Сравниваем байт в строке с нулем (конец строки)
    jz .end                     ; Если это конец строки, завершаем
    mov rax, [rdi + rcx]       ; Загружаем 8 байт из строки
    mov [rsi + rcx], rax       ; Копируем 8 байт в буфер
    inc rcx                     ; Увеличиваем счетчик символов
    jmp .loop                   ; Повторяем цикл
.error:
    xor rax, rax                ; Обнуляем rax (устанавливаем в 0, так как строка не умещается в буфер)
    ret                         ; Возвращаем 0
.end:
    mov byte [rsi + rcx], 0    ; Устанавливаем нуль-терминатор в конец буфера
    mov rax, rcx                ; Записываем длину строки в rax
    ret                         ; Возвращаем длину строки
